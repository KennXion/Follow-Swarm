/**
 * Admin User Management Controller
 * 
 * Handles all admin operations related to user management including
 * listing, updating, deleting, and suspending user accounts.
 */

const db = require('../../database');
const logger = require('../../utils/logger');

/**
 * Get paginated list of users with optional filters
 */
async function getUsers(req, res) {
  try {
    const { page = 1, limit = 50, search, status, tier } = req.query;
    const offset = (page - 1) * limit;
    
    // Build query with filters
    let query = `
      SELECT 
        id, spotify_id, display_name, email, 
        subscription_tier, subscription_plan, 
        status, is_verified, is_active,
        total_follows, followers,
        created_at, updated_at, last_login_at
      FROM users
      WHERE 1=1
    `;
    
    const queryParams = [];
    let paramCount = 0;
    
    if (search) {
      paramCount++;
      query += ` AND (display_name ILIKE $${paramCount} OR email ILIKE $${paramCount})`;
      queryParams.push(`%${search}%`);
    }
    
    if (status) {
      paramCount++;
      query += ` AND status = $${paramCount}`;
      queryParams.push(status);
    }
    
    if (tier) {
      paramCount++;
      query += ` AND subscription_tier = $${paramCount}`;
      queryParams.push(tier);
    }
    
    // Add ordering and pagination
    paramCount++;
    query += ` ORDER BY created_at DESC LIMIT $${paramCount}`;
    queryParams.push(parseInt(limit));
    
    paramCount++;
    query += ` OFFSET $${paramCount}`;
    queryParams.push(parseInt(offset));
    
    const result = await db.query(query, queryParams);
    
    // Get total count for pagination
    let countQuery = 'SELECT COUNT(*) as total FROM users WHERE 1=1';
    const countParams = [];
    paramCount = 0;
    
    if (search) {
      paramCount++;
      countQuery += ` AND (display_name ILIKE $${paramCount} OR email ILIKE $${paramCount})`;
      countParams.push(`%${search}%`);
    }
    
    if (status) {
      paramCount++;
      countQuery += ` AND status = $${paramCount}`;
      countParams.push(status);
    }
    
    if (tier) {
      paramCount++;
      countQuery += ` AND subscription_tier = $${paramCount}`;
      countParams.push(tier);
    }
    
    const countResult = await db.query(countQuery, countParams);
    const totalCount = parseInt(countResult.rows[0].total);
    
    res.json({
      success: true,
      data: {
        users: result.rows,
        pagination: {
          total: totalCount,
          page: parseInt(page),
          limit: parseInt(limit),
          totalPages: Math.ceil(totalCount / limit)
        }
      }
    });
  } catch (error) {
    logger.error('Admin get users error:', error);
    res.status(500).json({
      error: 'Failed to fetch users',
      message: error.message
    });
  }
}

/**
 * Get detailed user information
 */
async function getUserById(req, res) {
  try {
    const userResult = await db.query(
      `SELECT 
        id, spotify_id, display_name, email, followers, 
        subscription_tier, subscription_plan, subscription_status,
        status, is_verified, is_active, total_follows,
        created_at, updated_at, last_login_at
      FROM users 
      WHERE id = $1`,
      [req.params.userId]
    );
    
    if (userResult.rows.length === 0) {
      return res.status(404).json({
        error: 'User not found',
        message: 'The requested user does not exist'
      });
    }
    
    const user = userResult.rows[0];
    
    // Get user's recent follow activity
    const followsResult = await db.query(
      `SELECT COUNT(*) as total_follows
      FROM follows 
      WHERE follower_user_id = $1`,
      [req.params.userId]
    );
    
    user.followStats = {
      total: parseInt(followsResult.rows[0]?.total_follows || 0)
    };
    
    res.json({
      success: true,
      data: { user }
    });
  } catch (error) {
    logger.error('Admin get user error:', error);
    res.status(500).json({
      error: 'Failed to fetch user',
      message: error.message
    });
  }
}

/**
 * Update user details
 */
async function updateUser(req, res) {
  try {
    const { status, subscriptionPlan, isVerified } = req.body;
    
    // Check if user exists
    const userResult = await db.query(
      'SELECT * FROM users WHERE id = $1',
      [req.params.userId]
    );
    
    if (userResult.rows.length === 0) {
      return res.status(404).json({
        error: 'User not found',
        message: 'The requested user does not exist'
      });
    }
    
    // Build update query
    let updateFields = [];
    let queryParams = [];
    let paramCount = 0;
    
    if (status !== undefined) {
      paramCount++;
      updateFields.push(`status = $${paramCount}`);
      queryParams.push(status);
    }
    
    if (subscriptionPlan !== undefined) {
      paramCount++;
      updateFields.push(`subscription_plan = $${paramCount}`);
      queryParams.push(subscriptionPlan);
    }
    
    if (isVerified !== undefined) {
      paramCount++;
      updateFields.push(`is_verified = $${paramCount}`);
      queryParams.push(isVerified);
    }
    
    if (updateFields.length === 0) {
      return res.status(400).json({
        error: 'No updates provided',
        message: 'Please provide at least one field to update'
      });
    }
    
    // Add user ID to params
    paramCount++;
    queryParams.push(req.params.userId);
    
    // Execute update
    const updateResult = await db.query(
      `UPDATE users 
       SET ${updateFields.join(', ')}, updated_at = CURRENT_TIMESTAMP 
       WHERE id = $${paramCount}
       RETURNING *`,
      queryParams
    );
    
    res.json({
      success: true,
      message: 'User updated successfully',
      data: { user: updateResult.rows[0] }
    });
  } catch (error) {
    logger.error('Admin update user error:', error);
    res.status(500).json({
      error: 'Failed to update user',
      message: error.message
    });
  }
}

/**
 * Delete a user account
 */
async function deleteUser(req, res) {
  try {
    // Check if trying to delete self
    if (req.params.userId === req.user.id) {
      return res.status(400).json({
        error: 'Cannot delete self',
        message: 'Administrators cannot delete their own account'
      });
    }
    
    const userResult = await db.query(
      'SELECT * FROM users WHERE id = $1',
      [req.params.userId]
    );
    
    if (userResult.rows.length === 0) {
      return res.status(404).json({
        error: 'User not found',
        message: 'The requested user does not exist'
      });
    }
    
    // Soft delete by setting status to 'deleted'
    await db.query(
      "UPDATE users SET status = 'deleted', updated_at = CURRENT_TIMESTAMP WHERE id = $1",
      [req.params.userId]
    );
    
    res.json({
      success: true,
      message: 'User deleted successfully'
    });
  } catch (error) {
    logger.error('Admin user delete error:', error);
    res.status(500).json({
      error: 'Failed to delete user',
      message: error.message
    });
  }
}

/**
 * Suspend or unsuspend a user
 */
async function suspendUser(req, res) {
  try {
    const { reason, duration } = req.body;
    
    // Calculate suspension end date
    const suspensionEnds = duration 
      ? new Date(Date.now() + duration * 24 * 60 * 60 * 1000)
      : null;
    
    await db.query(
      `UPDATE users 
       SET status = 'suspended', 
           suspension_reason = $1,
           suspension_ends_at = $2,
           updated_at = CURRENT_TIMESTAMP
       WHERE id = $3`,
      [reason, suspensionEnds, req.params.userId]
    );
    
    logger.info('User suspended:', {
      userId: req.params.userId,
      adminId: req.user.id,
      reason,
      duration
    });
    
    res.json({
      success: true,
      message: 'User suspended successfully',
      data: {
        userId: req.params.userId,
        suspensionEnds
      }
    });
  } catch (error) {
    logger.error('Admin suspend user error:', error);
    res.status(500).json({
      error: 'Failed to suspend user',
      message: error.message
    });
  }
}

module.exports = {
  getUsers,
  getUserById,
  updateUser,
  deleteUser,
  suspendUser
};